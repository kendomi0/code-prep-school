<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CodePrepSchool</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <a href="index.html" class="title">CodePrepSchool</a>
        <nav class="nav-links">
            <a href="time-complexity.html" class="nav-item">
                Time Complexity
            </a>
            <a href="insertion-sort.html" class="nav-item">
                Insertion Sort
            </a>
        </nav>
        </header>
    <main>
        <div class="content-container">
            <div class="page-title">
                Time Complexity
            </div>
            <div class="page-body">
                Time complexity: How many times a piece of code runs.<br>
                <br>
                Let&rsquo;s take a look at time complexity. Understanding time complexity is important because optimizing your code to run as quickly as possible is essential. Code that takes longer to run is prone to loading issues, especially if multiple users are running that code simultaneously.<br>
                Look at this code that takes a name and reverses it.<br>
                <br>
                name = input(&ldquo;Type in your first name: &quot;);<br>
                reversed_name = &ldquo;&rdquo;<br>
                for char in name:<br>
                reversed_name = char + reversed_name<br>
                print(reversed_name)<br>
                <br>
                How many times would this code run? It would depend on the number of characters in name. For the name Jen, the for loop runs 3 times: to add J, then e, then n. For the name Mary-Kate, the for loop runs 9 times, counting the hyphen. We refer to the length of this input as &ldquo;n.&rdquo; Therefore, this code runs O(n) times, also known as a linear time complexity. The specific number doesn&rsquo;t matter because it&rsquo;s a constant and, in codes where users can give their own inputs, subject to change.<br>
                <br>
                Let's look at the time complexity if we rewrite this code to do the same thing in less lines.<br>
                <br>
                name = input(&ldquo;Type in your first name: )<br>
                print(name[::-1])<br>
                <br>
                One may believe that this would result in a faster time complexity. After all, it's only one line of code, right?<br>
                However, that's incorrect. Using techniques like slicing is great for readability, but they don't make time complexity faster. The time complexity for slicing is still O(n).<br>
                <br>
                Let&rsquo;s look at another code.<br>
                <br>
                nums = [2, 4, 6, 8, 10]<br>
                sum = 0<br>
                for num in nums:<br>
                sum += num<br>
                print(sum)<br>
                <br>
                Right now, our time complexity is O(n), because the for loop runs through the length of the list nums. <br>
                <br>
                Now, you may believe it could be optimized like this:<br>
                <br>
                nums = [2, 4, 6, 8, 10]<br>
                print(sum(nums))<br>
                <br>
                One may think that because this code uses a built-in method, the time complexity is quicker.<br>
                However, the time complexity is still O(n).<br>
                Don&rsquo;t be fooled into thinking less lines means lower time complexity.<br>
                <br>
                nums = [2, 4, 6]<br>
                print([x**2 for x in nums])<br>
                <br>
                It seems like since the code to create the new list is only one line long, the time complexity would be O(1), but this is not true.<br>
                <br>
                List comprehensions, as we have here, are still for loops. They&rsquo;re just shorthand for writing them. It helps to use them, because less lines of code generally makes your code more readable. (However, don&rsquo;t feel like it&rsquo;s necessary to use as few lines of code as possible. Code should be concise, meaning short, but also not dense. Cramming everything into one line can become dense if you&rsquo;re trying to do too many things at once.) But it doesn&rsquo;t improve our time complexity. The time complexity here is still O(n).<br>
                <br>
                Let&rsquo;s look at another code with a different time complexity.<br>
                <br>
                even_nums = [2, 4, 6, 8]<br>
                odd_nums = [1, 3, 5, 7, 9]<br>
                double_evens = [x*2 for x in even_nums]<br>
                double_odds = [y*2 for y in odd_nums]<br>
                print(double_evens, double_odds)<br>
                <br>
                You can see that in this code, we have 2 for loops in the form of list comprehensions in the variables double_evens and double_odds. We will refer to the length of even_nums as n and the length of odd_nums as m.<br>
                We simply add these, and our time complexity would be O(n + m). <br>
                <br>
                This is still considered a linear time complexity, because the exponents of the variables are still one.<br>
                <br>
                Come back soon for the next installment, a look at a case in which the time complexity is neither constant nor linear.<br>
        </div>
    </main>
    <footer>
        Github site by kendomi0
    </footer>
</body>
</html>