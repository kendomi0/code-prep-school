<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Insertion Sort</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
    <script src="https://kit.fontawesome.com/b3ffa80bf4.js" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/github-dark.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/languages/go.min.js"></script>
</head>
<body>
    <header id="app-header"></header>
    <script src="header.js"></script>
    <main>
        <div class="content-container">
            <div class="page-title">
                Insertion Sort
            </div>
            <div class="page-body">
                <p>Let&rsquo;s look at a relatively simple sorting algorithm, called insertion sort.</p>

                <p>Insertion sort is used to sort elements in ascending (increasing) or descending (decreasing) order. It compares each value to its previous value to determine if a shift is necessary, and if it is, the previous value shifts one position to the right. The shifting repeats until the value is correctly ordered within the already sorted part of the list.</p>

                <p>Let&rsquo;s look at this pseudocode for insertion sort. As this is pseudocode, we will be using 1-based indexing, so the first element is <span class="inline-code">A[1]</span>.</p>

                <pre>
                    <code class="language-python">
1   for j=2 to A.length: # Loop goes from second element to last element
2   key = A[j] # Variable stores the value of the element at the current index in the
	        # for loop
3   i = j - 1 # Variable stores the index before the current one in the for loop
4   while i > 0 and A[i] > key: # While the previous index is greater than 0, 
				# and the value at the previous index is greater than key
5       A[i + 1] = A[i] # Change the value at the next index 
			# to the value at the current index
6       i = i - 1  # Decrease i by 1
7   A[i + 1] = key # Change the value at the index after i to the value of key
                    </code>
                </pre>

                <p>Let&rsquo;s go through the logic of each line.</p>

                <p>Line 1 is a for loop that goes from the second element in the list to the last element. The first element is considered already sorted, because there is no previous element to compare it to.</p>

                <p>Line 2 uses a variable, <span class="inline-code">key</span>, to store the value in the list that is at the index <span class="inline-code">j</span>.</p>

                <p>Line 3 uses a variable, <span class="inline-code">i</span>, to store the index previous to <span class="inline-code">j</span>.</p>

                <p>Line 4 is a loop that runs while <span class="inline-code">i</span> is greater than 0 and the value in the list at the index <span class="inline-code">i</span> is greater than <span class="inline-code">key</span> (which is the value at <span class="inline-code">A[j]</span>).</p>

                <p>Line 5 changes the value that is at the index after <span class="inline-code">i</span> to the value that is at the index of <span class="inline-code">i</span>.</p>

                <p>Line 6 decreases the value of <span class="inline-code">i</span> by 1.</p>

                <p>Line 7 is outside of the while loop, but remains inside the for loop. It changes the value that is at the index after <span class="inline-code">i</span> to be the value of <span class="inline-code">key</span>.</p>

                <p>To explain the logic behind the code in shorthand form:</p>

                <p>The value at the current index in the for loop (<span class="inline-code">key</span>, which is <span class="inline-code">A[j]</span>) is compared to the value at the index before it (A[i]) to determine if a shift is necessary.</p>

                <p>If a shift is necessary, the value at <span class="inline-code">A[i]</span> shifts one to the right. Then <span class="inline-code">i</span> decreases by 1 to allow the while loop to run again if necessary. The while loop will need to run another time if <span class="inline-code">i</span> > 0, because that means there are additional elements that need to be changed to account for the changes that have already been made.</p>

                <p>Then after the while loop concludes, the for loop replaces the value after <span class="inline-code">A[i]</span> with the value of key.</p>

                <p></p>

                <p>Let&rsquo;s use an example to demonstrate what&rsquo;s happening in this code. We&rsquo;ll use the list <span class="inline-code">[4, 3, 1]</span>, and go through the first iteration of the for loop.</p>

                <pre>
                    <code class="language-python">
    A = [4, 3, 1]
    for j = 2 to A.length:
        key = A[j] # key = A[2], so key = 3
        i = j - 1 # i = 2 - 1, so i = 1
        while i > 0 and A[i] > key: # while i > 0 and A[1], which is 4, > 3
                        # Condition is satisfied, so while loop runs
            A[i + 1] = A[i] # A[1 + 1] = A[1], so A[2] = 4
            i = i - 1 # i = 1 - 1, so i = 0
                # While loop exits, because i is not greater than 0. 
        A[i + 1] = key # A[0 + 1] = 3 
                # Last line in the for loop for this iteration runs
                # Then the for loop starts again with the next element
                    </code>
                </pre>

                <p>Now our list reads <span class="inline-code">A = [3, 4, 1]</span>.</p>

                <p>Now for the second iteration of the for loop:</p>

                <pre>
                    <code class="language-python">
A = [3, 4, 1]
for j = 2 to A.length: # We are now on j = 3
    key = A[j] # key = A[3], so key = 1
    i = j - 1 # i = 3 - 1, so i = 2
    while i > 0 and A[i] > key: # while i > 0 and A[2], which is 4, > 1
                                # Condition is satisfied, so while loop runs
        A[i + 1] = A[i] # A[2 + 1] = A[2], so A[3] = 4
        i = i - 1 # i = 2 - 1, so i = 1
                # While loop continues, because i > 0
    A[i + 1] = key # This line does not run yet, because the while loop has not completed
                    </code>
                </pre>

                <p>The list is now <span class="inline-code">A = [3, 4, 4].</span></p>

                <p>For this iteration, the while loop runs a second time. Let&rsquo;s look at the second iteration of the while loop.</p>

                <pre>
                    <code class="language-python">
    while i > 0 and A[i] > key: # while i > 0 and A[1], which is 3, > 1
                    # Condition is satisfied, so while loop runs
        A[i + 1] = A[i] # A[1 + 1] = A[1], so A[2] = 3
        i = i - 1 # i = 1 - 1, so i = 0. 
            # While loop ends because i is not greater than 0
                    </code>
                </pre>

                <p>Now the list reads <span class="inline-code">A = [3, 3, 4]</span>.</p>

                <p>Now that the while loop has terminated for this iteration, we run the final line in the for loop.</p>

                <pre>
                    <code class="language-python">
        A[i + 1] = key # A[0 + 1] = key, so A[1] = 1
                    </code>
                </pre>

                <p>The fully sorted list is <span class="inline-code">A = [1, 3, 4]</span>.</p>

                <p>Now that you&rsquo;ve seen how insertion sort works, we can dive into its time complexity.</p>

                <p>We have two loops: the outer for loop and the inner while loop. The outer for loop has a time complexity of O(n), as it runs n times.</p>

                <p>The while loop can run up to n times, depending on whether the condition is met.</p>

                <p>Since the while loop is nested inside the for loop, we multiply O(n) * O(n) = O(n<sup>2</sup>).</p>

                <p>Therefore, when the list is sorted in reverse order and the while loop must run for every element, this results in the worst-case time complexity of <span class="inline-code">O(n<sup>2</sup>).</span></p>

                <p>The average-case time complexity is also <span class="inline-code">&#920;(n<sup>2</sup>)</span>, since on average, each element has to be compared with some previously sorted elements.</p>

                <p>In the best case, when the list is already sorted, the while loop never runs, only the for loop. Therefore, the best-case time complexity is <span class="inline-code">&#937;(n)</span>.</p>

                <p>Since most real data requires some sorting, insertion sort is considered in practice to have a time complexity of O(n<sup>2</sup>).</p>
            </div>
        </div>
    </main>
    <footer>
        Github site by kendomi0
    </footer>
<script>
  hljs.highlightAll();
</script>
</body>
</html>